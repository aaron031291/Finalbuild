/**
 * Data Structures
 * 
 * This file defines the core data structures used throughout the EdgeNativeUMaaS system,
 * providing efficient and specialized data structures for various system components.
 */

// Circular Buffer - Fixed-size buffer that overwrites oldest data when full
class CircularBuffer {
  constructor(capacity = 1000) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
    this.size = 0;
    this.head = 0;
    this.tail = 0;
  }
  
  push(item) {
    this.buffer[this.head] = item;
    this.head = (this.head + 1) % this.capacity;
    
    if (this.size &lt; this.capacity) {
      this.size++;
    } else {
      this.tail = (this.tail + 1) % this.capacity;
    }
    
    return this.size;
  }
  
  pop() {
    if (this.size === 0) {
      return undefined;
    }
    
    this.head = (this.head - 1 + this.capacity) % this.capacity;
    const item = this.buffer[this.head];
    this.buffer[this.head] = undefined;
    this.size--;
    
    return item;
  }
  
  shift() {
    if (this.size === 0) {
      return undefined;
    }
    
    const item = this.buffer[this.tail];
    this.buffer[this.tail] = undefined;
    this.tail = (this.tail + 1) % this.capacity;
    this.size--;
    
    return item;
  }
  
  get(index) {
    if (index &lt; 0 || index >= this.size) {
      return undefined;
    }
    
    return this.buffer[(this.tail + index) % this.capacity];
  }
  
  clear() {
    this.buffer = new Array(this.capacity);
    this.size = 0;
    this.head = 0;
    this.tail = 0;
  }
  
  toArray() {
    const result = [];
    
    for (let i = 0; i &lt; this.size; i++) {
      result.push(this.get(i));
    }
    
    return result;
  }
}

// Priority Queue - Queue where items have priorities
class PriorityQueue {
  constructor(comparator = (a, b) => a.priority - b.priority) {
    this.items = [];
    this.comparator = comparator;
  }
  
  enqueue(item) {
    // Add item to the end
    this.items.push(item);
    
    // Bubble up to maintain heap property
    this.bubbleUp(this.items.length - 1);
    
    return this.items.length;
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    
    // Get the highest priority item (root)
    const root = this.items[0];
    
    // Move the last item to the root
    const last = this.items.pop();
    
    if (this.items.length > 0) {
      this.items[0] = last;
      
      // Sink down to maintain heap property
      this.sinkDown(0);
    }
    
    return root;
  }
  
  peek() {
    return this.items[0];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
  
  bubbleUp(index) {
    const item = this.items[index];
    
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      const parent = this.items[parentIndex];
      
      // If parent has higher or equal priority, we're done
      if (this.comparator(parent, item) <= 0) {
        break;
      }
      
      // Swap with parent
      this.items[parentIndex] = item;
      this.items[index] = parent;
      
      // Move up
      index = parentIndex;
    }
  }
  
  sinkDown(index) {
    const item = this.items[index];
    const length = this.items.length;
    
    while (true) {
      const leftChildIndex = 2 * index + 1;
      const rightChildIndex = 2 * index + 2;
      let swapIndex = null;
      
      // Check if left child exists and has higher priority
      if (leftChildIndex &lt; length) {
        const leftChild = this.items[leftChildIndex];
        
        if (this.comparator(leftChild, item) &lt; 0) {
          swapIndex = leftChildIndex;
        }
      }
      
      // Check if right child exists and has higher priority
      if (rightChildIndex &lt; length) {
        const rightChild = this.items[rightChildIndex];
        
        if (
          (swapIndex === null && this.comparator(rightChild, item) &lt; 0) ||
          (swapIndex !== null && this.comparator(rightChild, this.items[swapIndex]) &lt; 0)
        ) {
          swapIndex = rightChildIndex;
        }
      }
      
      // If no swap needed, we're done
      if (swapIndex === null) {
        break;
      }
      
      // Swap with child
      this.items[index] = this.items[swapIndex];
      this.items[swapIndex] = item;
      
      // Move down
      index = swapIndex;
    }
  }
  
  toArray() {
    return [...this.items];
  }
}

// LRU Cache - Least Recently Used cache with fixed capacity
class LRUCache {
  constructor(capacity = 1000) {
    this.capacity = capacity;
    this.cache = new Map();
    this.head = { key: null, value: null, next: null, prev: null };
    this.tail = { key: null, value: null, next: null, prev: null };
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return undefined;
    }
    
    // Get node from cache
    const node = this.cache.get(key);
    
    // Move to front (most recently used)
    this.removeNode(node);
    this.addToFront(node);
    
    return node.value;
  }
  
  put(key, value) {
    // If key exists, update value and move to front
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      node.value = value;
      
      this.removeNode(node);
      this.addToFront(node);
      
      return;
    }
    
    // If at capacity, remove least recently used (from end)
    if (this.cache.size >= this.capacity) {
      const nodeToRemove = this.tail.prev;
      this.removeNode(nodeToRemove);
      this.cache.delete(nodeToRemove.key);
    }
    
    // Add new node to front
    const newNode = { key, value, next: null, prev: null };
    this.cache.set(key, newNode);
    this.addToFront(newNode);
  }
  
  remove(key) {
    if (!this.cache.has(key)) {
      return false;
    }
    
    const node = this.cache.get(key);
    this.removeNode(node);
    this.cache.delete(key);
    
    return true;
  }
  
  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  
  addToFront(node) {
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
  }
  
  clear() {
    this.cache = new Map();
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  
  keys() {
    return Array.from(this.cache.keys());
  }
  
  values() {
    return Array.from(this.cache.values()).map(node => node.value);
  }
  
  entries() {
    return Array.from(this.cache.entries()).map(([key, node]) => [key, node.value]);
  }
  
  size() {
    return this.cache.size;
  }
}

// Trie - Tree-like data structure for efficient string operations
class Trie {
  constructor() {
    this.root = {};
    this.size = 0;
  }
  
  insert(word) {
    if (!word) return false;
    
    let node = this.root;
    let isNewWord = false;
    
    for (const char of word) {
      if (!node[char]) {
        node[char] = {};
      }
      node = node[char];
    }
    
    if (!node.isEndOfWord) {
      node.isEndOfWord = true;
      this.size++;
      isNewWord = true;
    }
    
    return isNewWord;
  }
  
  search(word) {
    if (!word) return false;
    
    let node = this.root;
    
    for (const char of word) {
      if (!node[char]) {
        return false;
      }
      node = node[char];
    }
    
    return node.isEndOfWord === true;
  }
  
  startsWith(prefix) {
    if (!prefix) return false;
    
    let node = this.root;
    
    for (const char of prefix) {
      if (!node[char]) {
        return false;
      }
      node = node[char];
    }
    
    return true;
  }
  
  remove(word) {
    if (!word) return false;
    
    // Helper function to recursively remove
    const removeHelper = (node, word, index) => {
      // Base case: end of word
      if (index === word.length) {
        // If not the end of a word, nothing to remove
        if (!node.isEndOfWord) {
          return false;
        }
        
        // Remove end marker
        delete node.isEndOfWord;
        this.size--;
        
        // Return true if node has no children
        return Object.keys(node).length === 0;
      }
      
      const char = word[index];
      
      // If character doesn't exist, word not in trie
      if (!node[char]) {
        return false;
      }
      
      // Recursively remove from child
      const shouldDeleteChild = removeHelper(node[char], word, index + 1);
      
      // If child should be deleted
      if (shouldDeleteChild) {
        delete node[char];
        
        // Return true if node has no children and is not end of another word
        return Object.keys(node).length === 0 && !node.isEndOfWord;
      }
      
      return false;
    };
    
    return removeHelper(this.root, word, 0);
  }
  
  findAllWithPrefix(prefix) {
    const results = [];
    
    // Find the node for the prefix
    let node = this.root;
    
    for (const char of prefix) {
      if (!node[char]) {
        return results;
      }
      node = node[char];
    }
    
    // Helper function to collect all words from a node
    const collectWords = (node, currentPrefix, words) => {
      if (node.isEndOfWord) {
        words.push(currentPrefix);
      }
      
      for (const char in node) {
        if (char !== 'isEndOfWord') {
          collectWords(node[char], currentPrefix + char, words);
        }
      }
    };
    
    // Collect all words starting from the prefix node
    collectWords(node, prefix, results);
    
    return results;
  }
  
  clear() {
    this.root = {};
    this.size = 0;
  }
}

// BloomFilter - Space-efficient probabilistic data structure
class BloomFilter {
  constructor(size = 1000, hashFunctions = 3) {
    this.size = size;
    this.hashFunctions = hashFunctions;
    this.bits = new Array(size).fill(false);
  }
  
  add(item) {
    const hashes = this.getHashes(item);
    
    for (const hash of hashes) {
      this.bits[hash] = true;
    }
    
    return true;
  }
  
  contains(item) {
    const hashes = this.getHashes(item);
    
    for (const hash of hashes) {
      if (!this.bits[hash]) {
        return false;
      }
    }
    
    return true;
  }
  
  getHashes(item) {
    const hashes = [];
    const stringItem = String(item);
    
    for (let i = 0; i &lt; this.hashFunctions; i++) {
      const hash = this.hash(stringItem + i) %