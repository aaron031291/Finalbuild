/**
 * EdgeNativeUMaaS Blockchain Integration
 *
 * Integrates the blockchain components with the EdgeNativeUMaaS system.
 * Provides a unified interface for blockchain operations and connects
 * the blockchain with other system components.
 */

class BlockchainIntegration {
  constructor(system, config = {}) {
    this.system = system
    this.components = new Map()
    this.eventListeners = new Map()
    this.initialized = false

    // Default configuration
    this.config = {
      enabled: true,
      autoStart: true,
      logLevel: "info",
      blockchain: {
        enabled: true,
        algorithm: "PoW",
        blockTime: 15000,
      },
      transaction: {
        enabled: true,
        maxPendingTransactions: 1000,
      },
      consensus: {
        enabled: true,
        algorithm: "PoW",
      },
      metrics: {
        enabled: true,
        reportInterval: 60000, // 1 minute
      },
      ...config,
    }

    // Initialize components
    this.logger = new IntegrationLogger(this.config)
    this.metrics = new IntegrationMetrics(this.config)
  }

  /**
   * Initialize the blockchain integration
   */
  async initialize() {
    console.log("Initializing EdgeNativeUMaaS Blockchain Integration...")

    if (!this.system) {
      throw new Error("Cannot initialize Blockchain Integration: No system provided")
    }

    if (!this.config.enabled) {
      console.log("Blockchain Integration is disabled. Skipping initialization.")
      return {
        status: "disabled",
      }
    }

    // Initialize logger
    await this.logger.initialize()

    // Initialize metrics
    await this.metrics.initialize()

    // Initialize blockchain core
    const BlockchainCore = require("./blockchain-core")
    const blockchain = new BlockchainCore(this.system, this.config.blockchain)
    await blockchain.initialize()
    this.components.set("blockchain", blockchain)

    // Initialize transaction manager
    const BlockchainTransactionManager = require("./blockchain-transaction-manager")
    const transactionManager = new BlockchainTransactionManager(this.system, blockchain, this.config.transaction)
    await transactionManager.initialize()
    this.components.set("transaction", transactionManager)

    // Initialize consensus engine
    const BlockchainConsensusEngine = require("./blockchain-consensus-engine")
    const consensusEngine = new BlockchainConsensusEngine(this.system, blockchain, this.config.consensus)
    await consensusEngine.initialize()
    this.components.set("consensus", consensusEngine)

    // Register with system event bus
    if (this.system.eventBus) {
      this.system.eventBus.subscribe("system:start", this.handleSystemStart.bind(this))
      this.system.eventBus.subscribe("system:stop", this.handleSystemStop.bind(this))
      this.system.eventBus.subscribe("system:transaction:submit", this.handleTransactionSubmit.bind(this))
      this.system.eventBus.subscribe("system:transaction:status", this.handleTransactionStatus.bind(this))
      this.system.eventBus.subscribe("system:blockchain:status", this.handleBlockchainStatus.bind(this))
    }

    // Register component event listeners
    this.registerComponentEventListeners()

    // Start metrics reporting
    if (this.config.metrics.enabled) {
      this.startMetricsReporting()
    }

    this.initialized = true
    this.logger.info("Blockchain Integration initialized successfully")
    this.emit("blockchain:integration:initialized", { timestamp: Date.now() })

    // Auto-start if enabled
    if (this.config.autoStart) {
      this.start()
    }

    return {
      status: "initialized",
      components: Array.from(this.components.keys()),
    }
  }

  /**
   * Register component event listeners
   */
  registerComponentEventListeners() {
    // Blockchain core events
    const blockchain = this.components.get("blockchain")
    if (blockchain) {
      blockchain.on("blockchain:block:added", this.handleBlockAdded.bind(this))
      blockchain.on("blockchain:transaction:added", this.handleTransactionAdded.bind(this))
      blockchain.on("blockchain:chain:replaced", this.handleChainReplaced.bind(this))
    }

    // Transaction manager events
    const transactionManager = this.components.get("transaction")
    if (transactionManager) {
      transactionManager.on("transaction:submitted", this.handleTransactionSubmitted.bind(this))
      transactionManager.on("transaction:confirmed", this.handleTransactionConfirmed.bind(this))
      transactionManager.on("transaction:expired", this.handleTransactionExpired.bind(this))
    }

    // Consensus engine events
    const consensusEngine = this.components.get("consensus")
    if (consensusEngine) {
      consensusEngine.on("consensus:reached", this.handleConsensusReached.bind(this))
      consensusEngine.on("consensus:failed", this.handleConsensusFailed.bind(this))
    }
  }

  /**
   * Start the blockchain integration
   */
  start() {
    if (!this.initialized) {
      throw new Error("Blockchain Integration not initialized")
    }

    this.logger.info("Starting Blockchain Integration...")

    // Start blockchain mining
    const blockchain = this.components.get("blockchain")
    if (blockchain) {
      blockchain.startMining()
    }

    this.logger.info("Blockchain Integration started successfully")
    this.emit("blockchain:integration:started", { timestamp: Date.now() })

    return true
  }

  /**
   * Stop the blockchain integration
   */
  stop() {
    if (!this.initialized) {
      throw new Error("Blockchain Integration not initialized")
    }

    this.logger.info("Stopping Blockchain Integration...")

    // Stop blockchain mining
    const blockchain = this.components.get("blockchain")
    if (blockchain) {
      blockchain.stopMining()
    }

    this.logger.info("Blockchain Integration stopped successfully")
    this.emit("blockchain:integration:stopped", { timestamp: Date.now() })

    return true
  }

  /**
   * Start metrics reporting
   */
  startMetricsReporting() {
    this.logger.info(`Starting metrics reporting (interval: ${this.config.metrics.reportInterval}ms)`)

    this.metricsInterval = setInterval(() => {
      this.reportMetrics()
    }, this.config.metrics.reportInterval)
  }

  /**
   * Stop metrics reporting
   */
  stopMetricsReporting() {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval)
      this.metricsInterval = null
      this.logger.info("Metrics reporting stopped")
    }
  }

  /**
   * Report metrics
   */
  reportMetrics() {
    const metrics = this.getMetrics()

    // Emit metrics event
    this.emit("blockchain:metrics:updated", {
      metrics,
      timestamp: Date.now(),
    })

    // Publish to system event bus
    if (this.system.eventBus) {
      this.system.eventBus.publish("system:blockchain:metrics", {
        metrics,
        timestamp: Date.now(),
      })
    }

    this.logger.debug("Metrics reported")
  }

  /**
   * Submit a transaction
   */
  async submitTransaction(data) {
    if (!this.initialized) {
      throw new Error("Blockchain Integration not initialized")
    }

    const transactionManager = this.components.get("transaction")
    if (!transactionManager) {
      throw new Error("Transaction Manager not available")
    }

    // Create transaction
    const transaction = transactionManager.createTransaction(data)

    // Submit transaction
    return await transactionManager.submitTransaction(transaction)
  }

  /**
   * Get transaction status
   */
  getTransactionStatus(txId) {
    if (!this.initialized) {
      throw new Error("Blockchain Integration not initialized")
    }

    const transactionManager = this.components.get("transaction")
    if (!transactionManager) {
      throw new Error("Transaction Manager not available")
    }

    return transactionManager.getTransactionStatus(txId)
  }

  /**
   * Get blockchain status
   */
  getBlockchainStatus() {
    if (!this.initialized) {
      throw new Error("Blockchain Integration not initialized")
    }

    const blockchain = this.components.get("blockchain")
    if (!blockchain) {
      throw new Error("Blockchain Core not available")
    }

    return blockchain.getStatus()
  }

  /**
   * Get metrics
   */
  getMetrics() {
    const metrics = {
      timestamp: Date.now(),
      components: {},
    }

    // Collect metrics from all components
    for (const [name, component] of this.components.entries()) {
      if (typeof component.getMetrics === "function") {
        metrics.components[name] = component.getMetrics()
      }
    }

    // Add integration metrics
    metrics.integration = this.metrics.getMetrics()

    return metrics
  }

  /**
   * Handle system start event
   */
  handleSystemStart() {
    this.start()
  }

  /**
   * Handle system stop event
   */
  handleSystemStop() {
    this.stop()
  }

  /**
   * Handle transaction submit event
   */
  handleTransactionSubmit(data) {
    const { transaction, callback } = data

    this.submitTransaction(transaction)
      .then((result) => {
        if (typeof callback === "function") {
          callback(null, result)
        }
      })
      .catch((error) => {
        this.logger.error(`Error submitting transaction: ${error.message}`)
        if (typeof callback === "function") {
          callback(error)
        }
      })
  }

  /**
   * Handle transaction status event
   */
  handleTransactionStatus(data) {
    const { transactionId, callback } = data

    const status = this.getTransactionStatus(transactionId)

    if (typeof callback === "function") {
      callback(null, status)
    }
  }

  /**
   * Handle blockchain status event
   */
  handleBlockchainStatus(data) {
    const { callback } = data

    const status = this.getBlockchainStatus()

    if (typeof callback === "function") {
      callback(null, status)
    }
  }

  /**
   * Handle block added event
   */
  handleBlockAdded(data) {
    const { block } = data

    this.logger.info(`Block added to chain: ${block.index}`)

    // Update metrics
    this.metrics.recordBlockAdded(block)

    // Emit event
    this.emit("blockchain:integration:block:added", {
      block,
      timestamp: Date.now(),
    })
  }

  /**
   * Handle transaction added event
   */
  handleTransactionAdded(data) {
    const { transaction } = data

    this.logger.debug(`Transaction added to pool: ${transaction.id}`)

    // Update metrics
    this.metrics.recordTransactionAdded(transaction)
  }

  /**
   * Handle chain replaced event
   */
  handleChainReplaced(data) {
    const { chainLength } = data

    this.logger.info(`Blockchain replaced with longer chain (${chainLength} blocks)`)

    // Update metrics
    this.metrics.recordChainReplaced(chainLength)

    // Emit event
    this.emit("blockchain:integration:chain:replaced", {
      chainLength,
      timestamp: Date.now(),
    })
  }

  /**
   * Handle transaction submitted event
   */
  handleTransactionSubmitted(data) {
    const { transaction } = data

    this.logger.debug(`Transaction submitted: ${transaction.id}`)

    // Update metrics
    this.metrics.recordTransactionSubmitted(transaction)

    // Emit event
    this.emit("blockchain:integration:transaction:submitted", {
      transaction,
      timestamp: Date.now(),
    })
  }

  /**
   * Handle transaction confirmed event
   */
  handleTransactionConfirmed(data) {
    const { transaction, block } = data

    this.logger.info(`Transaction confirmed: ${transaction.id} in block ${block.index}`)

    // Update metrics
    this.metrics.recordTransactionConfirmed(transaction, block)

    // Emit event
    this.emit("blockchain:integration:transaction:confirmed", {
      transaction,
      block,
      timestamp: Date.now(),
    })
  }

  /**
   * Handle transaction expired event
   */
  handleTransactionExpired(data) {
    const { transaction } = data

    this.logger.debug(`Transaction expired: ${transaction.id}`)

    // Update metrics
    this.metrics.recordTransactionExpired(transaction)

    // Emit event
    this.emit("blockchain:integration:transaction:expired", {
      transaction,
      timestamp: Date.now(),
    })
  }

  /**
   * Handle consensus reached event
   */
  handleConsensusReached(data) {
    const { block, consensusTime } = data

    this.logger.info(`Consensus reached for block ${block.index} in ${consensusTime}ms`)

    // Update metrics
    this.metrics.recordConsensusReached(block, consensusTime)
  }

  /**
   * Handle consensus failed event
   */
  handleConsensusFailed(data) {
    const { block, reason, consensusTime } = data

    this.logger.warn(`Consensus failed for block ${block.index}: ${reason}`)

    // Update metrics
    this.metrics.recordConsensusFailed(block, reason, consensusTime)
  }

  /**
   * Register event listener
   */
  on(event, listener) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, [])
    }

    this.eventListeners.get(event).push(listener)
    return this
  }

  /**
   * Remove event listener
   */
  off(event, listener) {
    if (!this.eventListeners.has(event)) {
      return this
    }

    const listeners = this.eventListeners.get(event)
    const index = listeners.indexOf(listener)

    if (index !== -1) {
      listeners.splice(index, 1)
    }

    return this
  }

  /**
   * Emit event
   */
  emit(event, data) {
    if (!this.eventListeners.has(event)) {
      return false
    }

    const listeners = this.eventListeners.get(event)

    for (const listener of listeners) {
      try {
        listener(data)
      } catch (error) {
        this.logger.error(`Error in event listener: ${error.message}`)
      }
    }

    return true
  }

  /**
   * Shutdown the blockchain integration
   */
  async shutdown() {
    if (!this.initialized) {
      return true
    }

    this.logger.info("Shutting down Blockchain Integration...")

    // Stop metrics reporting
    this.stopMetricsReporting()

    // Shutdown all components
    for (const [name, component] of this.components.entries()) {
      if (typeof component.shutdown === "function") {
        try {
          await component.shutdown()
          this.logger.info(`Component ${name} shut down successfully`)
        } catch (error) {
          this.logger.error(`Error shutting down component ${name}: ${error.message}`)
        }
      }
    }

    this.initialized = false
    this.logger.info("Blockchain Integration shut down successfully")

    return true
  }
}

/**
 * Integration Logger
 */
class IntegrationLogger {
  constructor(config) {
    this.config = config
    this.logLevel = config.logLevel
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3,
    }
  }

  async initialize() {
    return true
  }

  /**
   * Log an error message
   */
  error(message) {
    this.log("error", message)
  }

  /**
   * Log a warning message
   */
  warn(message) {
    this.log("warn", message)
  }

  /**
   * Log an info message
   */
  info(message) {
    this.log("info", message)
  }

  /**
   * Log a debug message
   */
  debug(message) {
    this.log("debug", message)
  }

  /**
   * Log a message with the specified level
   */
  log(level, message) {
    if (this.levels[level] > this.levels[this.logLevel]) {
      return
    }

    console.log(`[BLOCKCHAIN INTEGRATION ${level.toUpperCase()}] ${message}`)
  }
}

/**
 * Integration Metrics
 */
class IntegrationMetrics {
  constructor(config) {
    this.config = config
    this.metrics = {
      blocksAdded: 0,
      transactionsAdded: 0,
      transactionsSubmitted: 0,
      transactionsConfirmed: 0,
      transactionsExpired: 0,
      chainsReplaced: 0,
      consensusReached: 0,
      consensusFailed: 0,
      averageBlockTime: 0,
      averageTransactionsPerBlock: 0,
      averageConsensusTime: 0,
      blockTimes: [],
      transactionsPerBlock: [],
      consensusTimes: [],
      timestamps: {
        firstBlock: 0,
        lastBlock: 0,
      },
    }
  }

  async initialize() {
    return true
  }

  /**
   * Record a block added
   */
  recordBlockAdded(block) {
    this.metrics.blocksAdded++

    // Update timestamps
    const now = Date.now()
    if (this.metrics.timestamps.firstBlock === 0) {
      this.metrics.timestamps.firstBlock = now
    }
    this.metrics.timestamps.lastBlock = now

    // Calculate block time
    if (this.metrics.blockTimes.length > 0) {
      const blockTime = now - this.metrics.timestamps.lastBlock
      this.metrics.blockTimes.push(blockTime)

      // Keep only the last 100 block times
      if (this.metrics.blockTimes.length > 100) {
        this.metrics.blockTimes.shift()
      }

      // Calculate average block time
      this.metrics.averageBlockTime =
        this.metrics.blockTimes.reduce((a, b) => a + b, 0) / this.metrics.blockTimes.length
    }

    // Update transactions per block
    const txCount = block.transactions ? block.transactions.length : 0
    this.metrics.transactionsPerBlock.push(txCount)

    // Keep only the last 100 values
    if (this.metrics.transactionsPerBlock.length > 100) {
      this.metrics.transactionsPerBlock.shift()
    }

    // Calculate average transactions per block
    this.metrics.averageTransactionsPerBlock =
      this.metrics.transactionsPerBlock.reduce((a, b) => a + b, 0) / this.metrics.transactionsPerBlock.length
  }

  /**
   * Record a transaction added
   */
  recordTransactionAdded(transaction) {
    this.metrics.transactionsAdded++
  }

  /**
   * Record a transaction submitted
   */
  recordTransactionSubmitted(transaction) {
    this.metrics.transactionsSubmitted++
  }

  /**
   * Record a transaction confirmed
   */
  recordTransactionConfirmed(transaction, block) {
    this.metrics.transactionsConfirmed++
  }

  /**
   * Record a transaction expired
   */
  recordTransactionExpired(transaction) {
    this.metrics.transactionsExpired++
  }

  /**
   * Record a chain replaced
   */
  recordChainReplaced(chainLength) {
    this.metrics.chainsReplaced++
  }

  /**
   * Record consensus reached
   */
  recordConsensusReached(block, consensusTime) {
    this.metrics.consensusReached++

    // Update consensus times
    this.metrics.consensusTimes.push(consensusTime)

    // Keep only the last 100 consensus times
    if (this.metrics.consensusTimes.length > 100) {
      this.metrics.consensusTimes.shift()
    }

    // Calculate average consensus time
    this.metrics.averageConsensusTime =
      this.metrics.consensusTimes.reduce((a, b) => a + b, 0) / this.metrics.consensusTimes.length
  }

  /**
   * Record consensus failed
   */
  recordConsensusFailed(block, reason, consensusTime) {
    this.metrics.consensusFailed++
  }

  /**
   * Get current metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      timestamp: Date.now(),
    }
  }
}

module.exports = BlockchainIntegration

