/**
 * EdgeNativeUMaaS Blockchain Transaction Manager
 *
 * Manages blockchain transactions, including creation, validation,
 * signing, and processing. Provides a high-level interface for
 * interacting with the blockchain through transactions.
 */

class BlockchainTransactionManager {
  constructor(system, blockchain, config = {}) {
    this.system = system
    this.blockchain = blockchain
    this.pendingTransactions = new Map()
    this.processedTransactions = new Map()
    this.eventListeners = new Map()
    this.initialized = false

    // Default configuration
    this.config = {
      enabled: true,
      maxPendingTransactions: 1000,
      transactionTTL: 3600000, // 1 hour in milliseconds
      cleanupInterval: 300000, // 5 minutes in milliseconds
      defaultFee: 0.001,
      priorityLevels: {
        low: 0.0005,
        medium: 0.001,
        high: 0.002,
      },
      logLevel: "info",
      ...config,
    }

    // Initialize components
    this.logger = new TransactionLogger(this.config)
    this.validator = new TransactionValidator(this.config)
    this.signer = new TransactionSigner(this.config)
    this.metrics = new TransactionMetrics(this.config)
  }

  /**
   * Initialize the transaction manager
   */
  async initialize() {
    console.log("Initializing EdgeNativeUMaaS Blockchain Transaction Manager...")

    if (!this.system) {
      throw new Error("Cannot initialize Transaction Manager: No system provided")
    }

    if (!this.blockchain) {
      throw new Error("Cannot initialize Transaction Manager: No blockchain provided")
    }

    if (!this.config.enabled) {
      console.log("Transaction Manager is disabled. Skipping initialization.")
      return {
        status: "disabled",
      }
    }

    // Initialize logger
    await this.logger.initialize()

    // Initialize metrics
    await this.metrics.initialize()

    // Register with system event bus
    if (this.system.eventBus) {
      this.system.eventBus.subscribe("system:transaction:submit", this.handleTransactionSubmit.bind(this))
      this.system.eventBus.subscribe("system:transaction:status", this.handleTransactionStatus.bind(this))
      this.system.eventBus.subscribe("system:block:added", this.handleBlockAdded.bind(this))
    }

    // Start cleanup interval
    this.startCleanupInterval()

    this.initialized = true
    this.logger.info("Transaction Manager initialized successfully")
    this.emit("transaction:manager:initialized", { timestamp: Date.now() })

    return {
      status: "initialized",
      pendingTransactions: this.pendingTransactions.size,
    }
  }

  /**
   * Start the cleanup interval
   */
  startCleanupInterval() {
    this.logger.info(`Starting transaction cleanup interval (${this.config.cleanupInterval}ms)`)

    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredTransactions()
    }, this.config.cleanupInterval)
  }

  /**
   * Stop the cleanup interval
   */
  stopCleanupInterval() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval)
      this.cleanupInterval = null
      this.logger.info("Transaction cleanup interval stopped")
    }
  }

  /**
   * Cleanup expired transactions
   */
  cleanupExpiredTransactions() {
    const now = Date.now()
    let expiredCount = 0

    // Check pending transactions
    for (const [txId, tx] of this.pendingTransactions.entries()) {
      if (now - tx.timestamp > this.config.transactionTTL) {
        this.pendingTransactions.delete(txId)
        expiredCount++

        this.logger.debug(`Expired transaction removed: ${txId}`)
        this.emit("transaction:expired", {
          transaction: tx,
          timestamp: now,
        })
      }
    }

    if (expiredCount > 0) {
      this.logger.info(`Cleaned up ${expiredCount} expired transactions`)
    }

    // Update metrics
    this.metrics.recordCleanup(expiredCount)
  }

  /**
   * Create a new transaction
   */
  createTransaction(data) {
    const { sender, recipient, amount, type = "transfer", metadata = {} } = data

    if (!sender || !recipient || amount === undefined) {
      throw new Error("Invalid transaction data: sender, recipient, and amount are required")
    }

    // Generate transaction ID
    const txId = this.generateTransactionId(sender, recipient, amount, Date.now())

    // Create transaction object
    const transaction = {
      id: txId,
      type,
      sender,
      recipient,
      amount: Number.parseFloat(amount),
      fee: data.fee || this.config.defaultFee,
      timestamp: Date.now(),
      metadata,
      status: "created",
    }

    this.logger.debug(`Transaction created: ${txId}`)

    return transaction
  }

  /**
   * Generate a transaction ID
   */
  generateTransactionId(sender, recipient, amount, timestamp) {
    // In a real implementation, this would use a cryptographic hash function
    // For this example, we'll use a simple concatenation with a random component
    const data = `${sender}:${recipient}:${amount}:${timestamp}:${Math.random()}`
    return "tx-" + this.simpleHash(data)
  }

  /**
   * Simple hash function for demo purposes
   */
  simpleHash(data) {
    let hash = 0
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i)
      hash = (hash << 5) - hash + char
      hash = hash & hash // Convert to 32bit integer
    }
    return Math.abs(hash).toString(16).padStart(12, "0")
  }

  /**
   * Sign a transaction
   */
  async signTransaction(transaction, privateKey) {
    if (!transaction || !privateKey) {
      throw new Error("Transaction and private key are required")
    }

    try {
      // Sign the transaction
      const signedTransaction = await this.signer.signTransaction(transaction, privateKey)

      this.logger.debug(`Transaction signed: ${transaction.id}`)

      return signedTransaction
    } catch (error) {
      this.logger.error(`Failed to sign transaction: ${error.message}`)
      throw error
    }
  }

  /**
   * Submit a transaction to the blockchain
   */
  async submitTransaction(transaction) {
    // Validate transaction
    if (!this.validator.validateTransaction(transaction)) {
      this.logger.warn(`Invalid transaction rejected: ${JSON.stringify(transaction)}`)
      throw new Error("Invalid transaction")
    }

    // Check if transaction already exists
    if (this.pendingTransactions.has(transaction.id) || this.processedTransactions.has(transaction.id)) {
      this.logger.warn(`Duplicate transaction rejected: ${transaction.id}`)
      throw new Error("Transaction already exists")
    }

    // Check if we've reached the maximum number of pending transactions
    if (this.pendingTransactions.size >= this.config.maxPendingTransactions) {
      this.logger.warn("Maximum pending transactions reached, rejecting new transaction")
      throw new Error("Maximum pending transactions reached")
    }

    // Update transaction status
    transaction.status = "pending"
    transaction.submittedAt = Date.now()

    // Add to pending transactions
    this.pendingTransactions.set(transaction.id, transaction)

    // Submit to blockchain
    const submitted = await this.blockchain.addTransaction(transaction)

    if (!submitted) {
      // If blockchain rejected the transaction, remove from pending
      this.pendingTransactions.delete(transaction.id)
      this.logger.warn(`Blockchain rejected transaction: ${transaction.id}`)
      throw new Error("Blockchain rejected transaction")
    }

    this.logger.info(`Transaction submitted: ${transaction.id}`)

    // Emit event
    this.emit("transaction:submitted", {
      transaction,
      timestamp: Date.now(),
    })

    // Update metrics
    this.metrics.recordSubmittedTransaction(transaction)

    return {
      id: transaction.id,
      status: transaction.status,
      timestamp: transaction.timestamp,
      submittedAt: transaction.submittedAt,
    }
  }

  /**
   * Get transaction status
   */
  getTransactionStatus(txId) {
    // Check pending transactions
    if (this.pendingTransactions.has(txId)) {
      const tx = this.pendingTransactions.get(txId)
      return {
        id: tx.id,
        status: tx.status,
        timestamp: tx.timestamp,
        submittedAt: tx.submittedAt,
      }
    }

    // Check processed transactions
    if (this.processedTransactions.has(txId)) {
      const tx = this.processedTransactions.get(txId)
      return {
        id: tx.id,
        status: tx.status,
        timestamp: tx.timestamp,
        submittedAt: tx.submittedAt,
        processedAt: tx.processedAt,
        blockIndex: tx.blockIndex,
        blockHash: tx.blockHash,
      }
    }

    // Transaction not found
    return {
      id: txId,
      status: "unknown",
    }
  }

  /**
   * Handle block added event
   */
  handleBlockAdded(data) {
    const { block } = data

    if (!block || !block.transactions) {
      return
    }

    this.logger.debug(`Processing ${block.transactions.length} transactions from new block ${block.index}`)

    // Process each transaction in the block
    for (const tx of block.transactions) {
      // Check if this is a pending transaction
      if (this.pendingTransactions.has(tx.id)) {
        const pendingTx = this.pendingTransactions.get(tx.id)

        // Update transaction status
        pendingTx.status = "confirmed"
        pendingTx.processedAt = Date.now()
        pendingTx.blockIndex = block.index
        pendingTx.blockHash = block.hash

        // Move from pending to processed
        this.pendingTransactions.delete(tx.id)
        this.processedTransactions.set(tx.id, pendingTx)

        this.logger.info(`Transaction confirmed: ${tx.id} in block ${block.index}`)

        // Emit event
        this.emit("transaction:confirmed", {
          transaction: pendingTx,
          block,
          timestamp: Date.now(),
        })

        // Update metrics
        this.metrics.recordConfirmedTransaction(pendingTx, block)
      }
    }
  }

  /**
   * Handle transaction submit event
   */
  handleTransactionSubmit(data) {
    const { transaction } = data

    this.submitTransaction(transaction).catch((error) => {
      this.logger.error(`Error submitting transaction: ${error.message}`)
    })
  }

  /**
   * Handle transaction status event
   */
  handleTransactionStatus(data) {
    const { transactionId, callback } = data

    const status = this.getTransactionStatus(transactionId)

    if (typeof callback === "function") {
      callback(status)
    }
  }

  /**
   * Register event listener
   */
  on(event, listener) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, [])
    }

    this.eventListeners.get(event).push(listener)
    return this
  }

  /**
   * Remove event listener
   */
  off(event, listener) {
    if (!this.eventListeners.has(event)) {
      return this
    }

    const listeners = this.eventListeners.get(event)
    const index = listeners.indexOf(listener)

    if (index !== -1) {
      listeners.splice(index, 1)
    }

    return this
  }

  /**
   * Emit event
   */
  emit(event, data) {
    if (!this.eventListeners.has(event)) {
      return false
    }

    const listeners = this.eventListeners.get(event)

    for (const listener of listeners) {
      try {
        listener(data)
      } catch (error) {
        this.logger.error(`Error in event listener: ${error.message}`)
      }
    }

    return true
  }

  /**
   * Get transaction manager status
   */
  getStatus() {
    return {
      initialized: this.initialized,
      pendingTransactions: this.pendingTransactions.size,
      processedTransactions: this.processedTransactions.size,
      metrics: this.metrics.getMetrics(),
    }
  }

  /**
   * Get transaction metrics
   */
  getMetrics() {
    return this.metrics.getMetrics()
  }

  /**
   * Shutdown the transaction manager
   */
  async shutdown() {
    if (!this.initialized) {
      return true
    }

    this.logger.info("Shutting down Transaction Manager...")

    // Stop cleanup interval
    this.stopCleanupInterval()

    this.initialized = false
    this.logger.info("Transaction Manager shut down successfully")

    return true
  }
}

/**
 * Transaction Logger
 */
class TransactionLogger {
  constructor(config) {
    this.config = config
    this.logLevel = config.logLevel
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3,
    }
  }

  async initialize() {
    return true
  }

  /**
   * Log an error message
   */
  error(message) {
    this.log("error", message)
  }

  /**
   * Log a warning message
   */
  warn(message) {
    this.log("warn", message)
  }

  /**
   * Log an info message
   */
  info(message) {
    this.log("info", message)
  }

  /**
   * Log a debug message
   */
  debug(message) {
    this.log("debug", message)
  }

  /**
   * Log a message with the specified level
   */
  log(level, message) {
    if (this.levels[level] > this.levels[this.logLevel]) {
      return
    }

    console.log(`[TRANSACTION ${level.toUpperCase()}] ${message}`)
  }
}

/**
 * Transaction Validator
 */
class TransactionValidator {
  constructor(config) {
    this.config = config
  }

  /**
   * Validate a transaction
   */
  validateTransaction(transaction) {
    // Check transaction structure
    if (
      !transaction.id ||
      !transaction.sender ||
      !transaction.recipient ||
      transaction.amount === undefined ||
      !transaction.timestamp
    ) {
      return false
    }

    // Check amount
    if (transaction.amount <= 0) {
      return false
    }

    // Check fee
    if (transaction.fee < 0) {
      return false
    }

    // Check signature if present
    if (transaction.signature) {
      return this.validateSignature(transaction)
    }

    return true
  }

  /**
   * Validate transaction signature
   */
  validateSignature(transaction) {
    // In a real implementation, this would verify the signature
    // For this example, we'll assume all signatures are valid
    return true
  }
}

/**
 * Transaction Signer
 */
class TransactionSigner {
  constructor(config) {
    this.config = config
  }

  /**
   * Sign a transaction
   */
  async signTransaction(transaction, privateKey) {
    // In a real implementation, this would sign the transaction with the private key
    // For this example, we'll simulate it

    // Create a copy of the transaction
    const signedTransaction = { ...transaction }

    // Add signature
    signedTransaction.signature = this.simulateSignature(transaction, privateKey)

    return signedTransaction
  }

  /**
   * Simulate a signature
   */
  simulateSignature(transaction, privateKey) {
    // In a real implementation, this would create a cryptographic signature
    // For this example, we'll use a simple simulation
    const data = JSON.stringify(transaction) + privateKey
    return "sig-" + this.simpleHash(data)
  }

  /**
   * Simple hash function for demo purposes
   */
  simpleHash(data) {
    let hash = 0
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i)
      hash = (hash << 5) - hash + char
      hash = hash & hash // Convert to 32bit integer
    }
    return Math.abs(hash).toString(16).padStart(12, "0")
  }
}

/**
 * Transaction Metrics
 */
class TransactionMetrics {
  constructor(config) {
    this.config = config
    this.metrics = {
      totalSubmitted: 0,
      totalConfirmed: 0,
      totalRejected: 0,
      totalExpired: 0,
      averageConfirmationTime: 0,
      confirmationTimes: [],
      transactionsByType: {},
      transactionsByHour: Array(24).fill(0),
      transactionsByDay: Array(7).fill(0),
      feeStats: {
        min: Number.POSITIVE_INFINITY,
        max: 0,
        avg: 0,
        total: 0,
      },
      amountStats: {
        min: Number.POSITIVE_INFINITY,
        max: 0,
        avg: 0,
        total: 0,
      },
      timestamps: {
        firstTransaction: 0,
        lastTransaction: 0,
      },
    }
  }

  async initialize() {
    return true
  }

  /**
   * Record a submitted transaction
   */
  recordSubmittedTransaction(transaction) {
    this.metrics.totalSubmitted++

    // Update timestamps
    const now = Date.now()
    if (this.metrics.timestamps.firstTransaction === 0) {
      this.metrics.timestamps.firstTransaction = now
    }
    this.metrics.timestamps.lastTransaction = now

    // Update transaction type stats
    const type = transaction.type || "unknown"
    if (!this.metrics.transactionsByType[type]) {
      this.metrics.transactionsByType[type] = 0
    }
    this.metrics.transactionsByType[type]++

    // Update time-based stats
    const date = new Date()
    this.metrics.transactionsByHour[date.getHours()]++
    this.metrics.transactionsByDay[date.getDay()]++

    // Update fee stats
    const fee = transaction.fee || 0
    this.metrics.feeStats.min = Math.min(this.metrics.feeStats.min, fee)
    this.metrics.feeStats.max = Math.max(this.metrics.feeStats.max, fee)
    this.metrics.feeStats.total += fee
    this.metrics.feeStats.avg = this.metrics.feeStats.total / this.metrics.totalSubmitted

    // Update amount stats
    const amount = transaction.amount || 0
    this.metrics.amountStats.min = Math.min(this.metrics.amountStats.min, amount)
    this.metrics.amountStats.max = Math.max(this.metrics.amountStats.max, amount)
    this.metrics.amountStats.total += amount
    this.metrics.amountStats.avg = this.metrics.amountStats.total / this.metrics.totalSubmitted
  }

  /**
   * Record a confirmed transaction
   */
  recordConfirmedTransaction(transaction, block) {
    this.metrics.totalConfirmed++

    // Calculate confirmation time
    const confirmationTime = transaction.processedAt - transaction.submittedAt
    this.metrics.confirmationTimes.push(confirmationTime)

    // Keep only the last 100 confirmation times
    if (this.metrics.confirmationTimes.length > 100) {
      this.metrics.confirmationTimes.shift()
    }

    // Calculate average confirmation time
    this.metrics.averageConfirmationTime =
      this.metrics.confirmationTimes.reduce((a, b) => a + b, 0) / this.metrics.confirmationTimes.length
  }

  /**
   * Record a rejected transaction
   */
  recordRejectedTransaction(transaction) {
    this.metrics.totalRejected++
  }

  /**
   * Record expired transactions cleanup
   */
  recordCleanup(expiredCount) {
    this.metrics.totalExpired += expiredCount
  }

  /**
   * Get current metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      timestamp: Date.now(),
    }
  }
}

module.exports = BlockchainTransactionManager

