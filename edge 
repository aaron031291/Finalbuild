class SystemDemo {
  constructor(options = {}) {
    this.id = options.id || `system-demo-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
    this.name = options.name || "EdgeNativeUMaaS System Demo";
    this.description = options.description || "A comprehensive demonstration of the EdgeNativeUMaaS system capabilities";
    
    // Core system
    this.edgeNativeSystem = null;
    
    // Demo state
    this.isInitialized = false;
    this.demoScenarios = new Map();
    this.activeScenarios = new Map();
    this.demoResults = [];
    
    // Configuration
    this.config = {
      systemOptions: options.systemOptions || {},
      scenariosToRun: options.scenariosToRun || ['basic', 'memory', 'compute', 'quantum', 'network', 'security'],
      autoStart: options.autoStart !== undefined ? options.autoStart : false,
      logLevel: options.logLevel || 'info',
      ...options.demoConfig
    };
    
    // Logging
    this.logSystem = new LogSystem(this.config.logLevel);
    
    // Initialize scenarios
    this.initializeScenarios();
    
    // Auto-start if configured
    if (this.config.autoStart) {
      this.initialize().then(() => {
        return this.runAllScenarios();
      }).catch(err => {
        this.logSystem.error(`Auto-start failed: ${err.message}`);
      });
    }
  }
  
  initializeScenarios() {
    // Define available demo scenarios
    this.demoScenarios.set('basic', {
      name: 'Basic System Functionality',
      description: 'Demonstrates basic system initialization and status reporting',
      run: this.runBasicScenario.bind(this)
    });
    
    this.demoScenarios.set('memory', {
      name: 'Universal Memory Operations',
      description: 'Demonstrates universal memory block creation, distribution, and persistence',
      run: this.runMemoryScenario.bind(this)
    });
    
    this.demoScenarios.set('compute', {
      name: 'Compute Allocation and Execution',
      description: 'Demonstrates compute allocation, sharing, and execution',
      run: this.runComputeScenario.bind(this)
    });
    
    this.demoScenarios.set('quantum', {
      name: 'Quantum Processing',
      description: 'Demonstrates quantum circuit creation and execution',
      run: this.runQuantumScenario.bind(this)
    });
    
    this.demoScenarios.set('network', {
      name: 'Network and Data Transfer',
      description: 'Demonstrates mycelium network and quantum data highway operations',
      run: this.runNetworkScenario.bind(this)
    });
    
    this.demoScenarios.set('security', {
      name: 'Security and Protection',
      description: 'Demonstrates rainbow shield security features',
      run: this.runSecurityScenario.bind(this)
    });
    
    this.demoScenarios.set('integration', {
      name: 'System Integration',
      description: 'Demonstrates integration with external systems',
      run: this.runIntegrationScenario.bind(this)
    });
    
    this.demoScenarios.set('healing', {
      name: 'Self-Healing Infrastructure',
      description: 'Demonstrates self-healing capabilities',
      run: this.runHealingScenario.bind(this)
    });
    
    this.demoScenarios.set('comprehensive', {
      name: 'Comprehensive System Test',
      description: 'Runs a comprehensive test of all system capabilities',
      run: this.runComprehensiveScenario.bind(this)
    });
  }
  
  async initialize() {
    this.logSystem.info(`Initializing ${this.name}`);
    
    try {
      // Create the edge native system
      this.edgeNativeSystem = new EdgeNativeUniversalSystem({
        name: "Demo Edge Native System",
        autoStart: false,
        logLevel: this.config.logLevel,
        ...this.config.systemOptions
      });
      
      // Initialize the system
      await this.edgeNativeSystem.initialize();
      
      this.isInitialized = true;
      this.logSystem.info(`${this.name} initialized successfully`);
      
      return true;
    } catch (error) {
      this.logSystem.error(`Initialization failed: ${error.message}`);
      throw error;
    }
  }
  
  async runScenario(scenarioId) {
    if (!this.isInitialized) {
      throw new Error("Demo must be initialized before running scenarios");
    }
    
    if (!this.demoScenarios.has(scenarioId)) {
      throw new Error(`Unknown scenario: ${scenarioId}`);
    }
    
    const scenario = this.demoScenarios.get(scenarioId);
    
    this.logSystem.info(`Running scenario: ${scenario.name}`);
    
    // Start the system if not already running
    if (this.edgeNativeSystem.systemStatus !== 'running') {
      await this.edgeNativeSystem.start();
    }
    
    // Mark scenario as active
    this.activeScenarios.set(scenarioId, {
      id: scenarioId,
      startTime: Date.now(),
      status: 'running'
    });
    
    try {
      // Run the scenario
      const result = await scenario.run();
      
      // Update scenario status
      const activeScenario = this.activeScenarios.get(scenarioId);
      activeScenario.status = 'completed';
      activeScenario.endTime = Date.now();
      activeScenario.duration = activeScenario.endTime - activeScenario.startTime;
      activeScenario.result = result;
      
      // Add to results
      this.demoResults.push({
        scenarioId,
        name: scenario.name,
        startTime: activeScenario.startTime,
        endTime: activeScenario.endTime,
        duration: activeScenario.duration,
        success: true,
        result
      });
      
      this.logSystem.info(`Scenario completed: ${scenario.name}`);
      
      return result;
    } catch (error) {
      // Update scenario status
      const activeScenario = this.activeScenarios.get(scenarioId);
      activeScenario.status = 'failed';
      activeScenario.endTime = Date.now();
      activeScenario.duration = activeScenario.endTime - activeScenario.startTime;
      activeScenario.error = error.message;
      
      // Add to results
      this.demoResults.push({
        scenarioId,
        name: scenario.name,
        startTime: activeScenario.startTime,
        endTime: activeScenario.endTime,
        duration: activeScenario.duration,
        success: false,
        error: error.message
      });
      
      this.logSystem.error(`Scenario failed: ${scenario.name} - ${error.message}`);
      
      throw error;
    }
  }
  
  async runAllScenarios() {
    if (!this.isInitialized) {
      throw new Error("Demo must be initialized before running scenarios");
    }
    
    this.logSystem.info("Running all configured scenarios");
    
    const results = [];
    
    for (const scenarioId of this.config.scenariosToRun) {
      try {
        const result = await this.runScenario(scenarioId);
        results.push({
          scenarioId,
          success: true,
          result
        });
      } catch (error) {
        results.push({
          scenarioId,
          success: false,
          error: error.message
        });
        
        // Continue with other scenarios even if one fails
        this.logSystem.warn(`Continuing with next scenario after failure in ${scenarioId}`);
      }
    }
    
    this.logSystem.info("All scenarios completed");
    
    return {
      totalScenarios: results.length,
      successfulScenarios: results.filter(r => r.success).length,
      failedScenarios: results.filter(r => !r.success).length,
      results
    };
  }
  
  async shutdown() {
    this.logSystem.info("Shutting down demo");
    
    if (this.edgeNativeSystem) {
      await this.edgeNativeSystem.shutdown();
    }
    
    this.isInitialized = false;
    
    this.logSystem.info("Demo shut down successfully");
    
    return true;
  }
  
  // Individual scenario implementations
  
  async runBasicScenario() {
    this.logSystem.info("Running Basic System Functionality scenario");
    
    // Get system status
    const systemStatus = await this.edgeNativeSystem.getSystemStatus();
    
    // Verify system components
    const componentChecks = {
      universalComputeMemory: systemStatus.components.universalComputeMemory.status === 'running',
      blockchainComputeSharing: systemStatus.components.blockchainComputeSharing.status === 'running',
      realTimeMemoryDistribution: systemStatus.components.realTimeMemoryDistribution.status === 'running',
      universalPersistentMemory: systemStatus.components.universalPersistentMemory.status === 'running',
      crossContextBridge: systemStatus.components.crossContextBridge.status === 'running',
      quantumDataHighway: systemStatus.components.quantumDataHighway.status === 'running',
      myceliumNetwork: systemStatus.components.myceliumNetwork.status === 'running',
      rainbowShield: systemStatus.components.rainbowShield.shieldStatus === 'active'
    };
    
    const allComponentsRunning = Object.values(componentChecks).every(status => status === true);
    
    return {
      systemId: systemStatus.id,
      systemName: systemStatus.name,
      systemVersion: systemStatus.version,
      systemStatus: systemStatus.status,
      allComponentsRunning,
      componentChecks,
      metrics: systemStatus.metrics
    };
  }
  
  async runMemoryScenario() {
    this.logSystem.info("Running Universal Memory Operations scenario");
    
    // Create a memory block
    const memoryBlock = await this.edgeNativeSystem.createMemoryBlock(1024 * 1024, {
      name: 'demo-memory-block',
      persistent: true,
      distributed: true,
      persistenceOptions: {
        redundancy: 'high',
        syncFrequency: 'immediate'
      },
      distributionOptions: {
        strategy: 'balanced',
        priority: 'high'
      }
    });
    
    // Write data to the memory block
    const writeResult = await this.edgeNativeSystem.universalComputeMemory.writeToMemoryBlock(
      memoryBlock.id,
      { demoData: "This is test data for the memory scenario", timestamp: Date.now() }
    );
    
    // Verify data is distributed
    const distributionStatus = await this.edgeNativeSystem.realTimeMemoryDistribution.getDistributionStatus(memoryBlock.id);
    
    // Verify data is persisted
    const persistenceStatus = await this.edgeNativeSystem.universalPersistentMemory.getPersistenceStatus(memoryBlock.id);
    
    // Read data back
    const readResult = await this.edgeNativeSystem.universalComputeMemory.readFromMemoryBlock(memoryBlock.id);
    
    return {
      memoryBlockId: memoryBlock.id,
      memoryBlockSize: memoryBlock.size,
      writeSuccess: writeResult.success,
      distributionStatus,
      persistenceStatus,
      readSuccess: readResult !== null,
      dataIntegrityMaintained: readResult.demoData === "This is test data for the memory scenario"
    };
  }
  
  async runComputeScenario() {
    this.logSystem.info("Running Compute Allocation and Execution scenario");
    
    // Allocate compute
    const compute = await this.edgeNativeSystem.allocateCompute({
      cpu: 2,
      memory: 512 * 1024 * 1024,
      priority: 'normal'
    }, {
      name: 'demo-compute',
      shared: true
    });
    
    // Define a simple computation
    const computeFunction = `
      function compute(input) {
        let result = 0;
        for (let i = 0; i < input.iterations; i++) {
          result += Math.sqrt(i);
        }
        return {
          input: input,
          result: result,
          completed: true
        };
      }
    `;
    
    // Load the function
    const loadResult = await this.edgeNativeSystem.universalComputeMemory.loadComputeFunction(
      compute.computeId,
      computeFunction
    );
    
    // Execute the computation
    const executionResult = await this.edgeNativeSystem.executeCompute(
      compute.computeId,
      { iterations: 1000000 }
    );
    
    // Get compute metrics
    const computeMetrics = await this.edgeNativeSystem.universalComputeMemory.getComputeMetrics(compute.computeId);
    
    return {
      computeId: compute.computeId,
      loadSuccess: loadResult.success,
      executionSuccess: executionResult.completed,
      executionResult,
      computeMetrics
    };
  }
  
  async runQuantumScenario() {
    this.logSystem.info("Running Quantum Processing scenario");
    
    // Skip if quantum is not enabled
    if (!this.edgeNativeSystem.config.quantumEnabled) {
      return {
        skipped: true,
        reason: "Quantum processing is not enabled in the system configuration"
      };
    }
    
    // Create a quantum circuit for superposition and entanglement
    const circuit = await this.edgeNativeSystem.quantumProcessor.createQuantumCircuit({
      name: 'demo-quantum-circuit',
      qubitCount: 2,
      gates: [
        { type: 'H', qubits: [0] },          // Hadamard on qubit 0
        { type: 'CNOT', qubits: [0, 1] },    // CNOT with control qubit 0, target qubit 1
        { type: 'measure', qubits: [0, 1] }  // Measure both qubits
      ]
    });
    
    // Execute the circuit
    const executionResult = await this.edgeNativeSystem.quantumProcessor.executeCircuit(
      circuit.circuitId,
      {}
    );
    
    // Generate a quantum key
    const keyResult = await this.edgeNativeSystem.generateQuantumSecureKey(256);
    
    return {
      circuitId: circuit.circuitId,
      executionSuccess: executionResult.status === 'completed',
      executionResult,
      keyId: keyResult.keyId,
      keySize: keyResult.size
    };
  }
  
  async runNetworkScenario() {
    this.logSystem.info("Running Network and Data Transfer scenario");
    
    // Create two memory blocks to serve as endpoints
    const sourceBlock = await this.edgeNativeSystem.createMemoryBlock(1024 * 1024, {
      name: 'source-block'
    });
    
    const targetBlock = await this.edgeNativeSystem.createMemoryBlock(1024 * 1024, {
      name: 'target-block'
    });
    
    // Create a data channel between them
    const channel = await this.edgeNativeSystem.createDataChannel(
      sourceBlock.id,
      targetBlock.id,
      {
        name: 'demo-channel',
        bandwidth: 'high',
        priority: 'normal',
        secure: true
      }
    );
    
    // Write test data to source block
    await this.edgeNativeSystem.universalComputeMemory.writeToMemoryBlock(
      sourceBlock.id,
      { message: "Network test data", timestamp: Date.now() }
    );
    
    // Send data through the channel
    const sendResult = await this.edgeNativeSystem.sendData(
      channel.channelId,
      { command: "COPY_DATA", sourceId: sourceBlock.id }
    );
    
    // Wait for data transfer to complete
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Read data from target block
    const targetData = await this.edgeNativeSystem.universalComputeMemory.readFromMemoryBlock(targetBlock.id);
    
    // Get network metrics
    const networkMetrics = await this.edgeNativeSystem.myceliumNetwork.getMetrics();
    
    return {
      channelId: channel.channelId,
      sourceId: sourceBlock.id,
      targetId: targetBlock.id,
      sendSuccess: sendResult.status === 'sent',
      dataTransferSuccess: targetData !== null && targetData.message === "Network test data",
      networkMetrics
    };
  }
  
  async runSecurityScenario() {
    this.logSystem.info("Running Security and Protection scenario");
    
    // Get current security status
    const initialSecurityStatus = await this.edgeNativeSystem.rainbowShield.getSecurityReport();
    
    // Create a security context
    const securityContext = await this.edgeNativeSystem.rainbowShield.createSecurityContext('demo-context', {
      accessLevel: 'restricted',
      encryptionStrength: 'high',
      auditFrequency: 'continuous'
    });
    
    // Authorize access to the context
    const authResult = await this.edgeNativeSystem.rainbowShield.authorizeAccess(
      'demo-context',
      { username: 'demo-user', password: 'demo-password' }
    );
    
    // Process some data through the security shield
    const securityProcessingResult = await this.edgeNativeSystem.rainbowShield.processDataThroughShield(
      { sensitiveData: "This is sensitive information", classification: "confidential" },
      'demo-context'
    );
    
    // Simulate a security scan
    const scanResult = await this.edgeNativeSystem.rainbowShield.performSecurityScan();
    
    // Get updated security status
    const finalSecurityStatus = await this.edgeNativeSystem.rainbowShield.getSecurityReport();
    
    return {
      contextId: 'demo-context',
      authSuccess: authResult.authorized,
      tokenId: authResult.authorized ? authResult.token.id : null,
      dataProcessingSuccess: securityProcessingResult.isClean,
      threatDetections: scanResult.threatsDetected,
      initialSecurityStatus: {
        shieldStatus: initialSecurityStatus.shieldStatus,
        protectionLayers: initialSecurityStatus.protectionLayers,
        incidents: initialSecurityStatus.incidents
      },
      finalSecurityStatus: {
        shieldStatus: finalSecurityStatus.shieldStatus,
        protectionLayers: finalSecurityStatus.protectionLayers,
        incidents: finalSecurityStatus.incidents
      }
    };
  }
  
  async runIntegrationScenario() {
    this.logSystem.info("Running System Integration scenario");
    
    // Register an external system
    const externalSystem = await this.edgeNativeSystem.registerExternalSystem({
      name: 'demo-external-system',
      endpoint: 'https://demo-external-system.example.com/api',
      type: 'rest-api'
    }, {
      createBridge: true,
      bridgeOptions: {
        type: 'http-bridge',
        authentication: 'token'
      }
    });
    
    // Create a virtual environment
    const environment = await this.edgeNativeSystem.createVirtualEnvironment({
      name: 'demo-environment',
      memorySize: 256 * 1024 * 1024,
      computeRequirements: {
        cpu: 1,
        memory: 128 * 1024 * 1024
      },
      persistent: true,
      distributed: true,
      securityLevel: 'high'
    });
    
    // Connect the external system to the virtual environment
    const connection = await this.edgeNativeSystem.universalIntegrationLayer.connectServices(
      externalSystem.serviceId,
      environment.serviceId,
      {
        protocol: 'https',
        dataFormat: 'json',
        securityLevel: 'high'
      }
    );
    
    return {
      externalSystemId: externalSystem.serviceId,
      environmentId: environment.environmentId,
      connectionId: connection.connectionId,
      bridgeId: environment.bridgeId,
      integrationSuccess: connection.status === 'active'
    };
  }
  
  async runHealingScenario() {
    this.logSystem.info("Running Self-Healing Infrastructure scenario");
    
    // Get initial healing status
    const initialHealingStatus = await this.edgeNativeSystem.selfHealingInfrastructure.getSystemStatus();
    
    // Create a system backup
    const backupResult = await this.edgeNativeSystem.selfHealingInfrastructure.createSystemBackup();
    
    // Simulate an issue with a component
    const componentId = 'universal-compute-memory';
    const issueDetails = {
      type: 'resource-exhaustion',
      severity: 'medium',
      details: 'Memory usage exceeds threshold for demo purposes'
    };
    
    const issueId = await this.edgeNativeSystem.selfHealingInfrastructure.createIssue(
      componentId,
      issueDetails
    );
    
    // Trigger repair
    const repairResult = await this.edgeNativeSystem.selfHealingInfrastructure.repairComponent(
      componentId,
      issueId
    );
    
    // Get final healing status
    const finalHealingStatus = await this.edgeNativeSystem.selfHealingInfrastructure.getSystemStatus();
    
    return {
      backupId: backupResult.backupId,
      issueId,
      componentId,
      repairSuccess: repairResult.success,
      initialStatus: {
        componentCount: initialHealingStatus.componentCount,
        healthyComponentCount: initialHealingStatus.healthyComponentCount,
        activeIssueCount: initialHealingStatus.activeIssueCount
      },
      finalStatus: {
        componentCount: finalHealingStatus.componentCount,
        healthyComponentCount: finalHealingStatus.healthyComponentCount,
        activeIssueCount: finalHealingStatus.activeIssueCount
      }
    };
  }
  
  async runComprehensiveScenario() {
    this.logSystem.info("Running Comprehensive System Test scenario");
    
    // Run all individual scenarios
    const results = {};
    
    // Basic functionality
    results.basic = await this.runBasicScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Memory operations
    results.memory = await this.runMemoryScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Compute operations
    results.compute = await this.runComputeScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Quantum operations (if enabled)
    if (this.edgeNativeSystem.config.quantumEnabled) {
      results.quantum = await this.runQuantumScenario().catch(err => ({
        success: false,
        error: err.message
      }));
    }
    
    // Network operations
    results.network = await this.runNetworkScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Security operations
    results.security = await this.runSecurityScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Integration operations
    results.integration = await this.runIntegrationScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Healing operations
    results.healing = await this.runHealingScenario().catch(err => ({
      success: false,
      error: err.message
    }));
    
    // Calculate overall success
    const scenarioResults = Object.values(results);
    const successfulScenarios = scenarioResults.filter(r => !r.error && !r.skipped).length;
    const skippedScenarios = scenarioResults.filter(r => r.skipped).length;
    const failedScenarios = scenarioResults.filter(r => r.error).length;
    
    return {
      totalScenarios: scenarioResults.length,
      successfulScenarios,
      skippedScenarios,
      failedScenarios,
      success: failedScenarios === 0,
      scenarioResults: results
    };
  }
  
  getDemoResults() {
    return {
      id: this.id,
      name: this.name,
      totalScenarios: this.demoResults.length,
      successfulScenarios: this.demoResults.filter(r => r.success).length,
      failedScenarios: this.demoResults.filter(r => !r.success).length,
      results: this.demoResults
    };
  }
}

// Helper class for logging (same as in EdgeNativeUniversalSystem)
class LogSystem {
  constructor(level = 'info') {
    this.level = level;
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
  }
  
  shouldLog(level) {
    return this.levels[level] >= this.levels[this.level];
  }
  
  debug(message) {
    if (this.shouldLog('debug')) {
      console.log(`[DEBUG] ${message}`);
    }
  }
  
  info(message) {
    if (this.shouldLog('info')) {
      console.log(`[INFO] ${message}`);
    }
  }
  
  warn(message) {
    if (this.shouldLog('warn')) {
      console.warn(`[WARN] ${message}`);
    }
  }
  
  error(message) {
    if (this.shouldLog('error')) {
      console.error(`[ERROR] ${message}`);
    }
  }
}

module.exports = SystemDemo;